# EAI｜02.12 数据结构与算法 课程讲义  
课程名称：数据结构与算法  
单元主题：排序基础｜智能数据处理  
授课年级：G3+  
计划课时：90分钟  

## 课程概括  
本课以机器人环境感知数据处理为核心场景，系统学习基础排序算法的工作原理与性能特征。通过实现激光雷达点云排序和传感器噪声过滤系统，掌握冒泡排序与选择排序的实现策略，理解时间复杂度分析的重要性，为后续高效排序算法学习奠定基础。  

## 教学目标  
### 🎯知识与技能  
1. 掌握冒泡排序的相邻元素交换策略  
2. 理解选择排序的最小值定位机制  
3. 熟练分析算法时间复杂度（O(n²)）  

### 🎯过程与方法  
1. 通过数据可视化观察排序过程  
2. 采用渐近分析法比较算法性能  

### 🎯情感态度价值观  
1. 培养算法优化的探索精神  
2. 增强数据处理的责任意识  

## 重点难点  
| 教学重点 | 教学难点 |  
|----------|----------|  
| ✅ 排序算法的稳定性比较 | ⚠️ 逆序数据处理策略 |  
| ✅ 时间复杂度的数学推导 | ⚠️ 算法实际耗时与理论差异 |  
| ✅ 传感器噪声数据清洗 | ⚠️ 多维度数据联合排序 |  

## 教学准备  
| 软件 | 硬件 | 扩展 |  
|------|------|------|  
| Python 3.10+ | 　 | [点云数据集](https://bit.ly/12lidar_data) |  
| Matplotlib | 　 | [排序可视化工具](https://bit.ly/12sort_vis) |  

## 教学过程  
| 环节 | 主要内容 | 预计时长 | 素材附件 |  
|------|----------|----------|----------|  
| 环节1: 情境导入 | ● 播放自动驾驶点云处理视频<br>● 分析乱序数据对SLAM的影响 | 10分钟 | [点云处理DEMO](https://bit.ly/12pcdemo) |  
| 环节2: 算法解析 | ● 冒泡排序的"气泡上浮"类比<br>● 选择排序的"擂台比武"演示<br>● 时间复杂度对比实验 | 25分钟 | [算法对比表](https://bit.ly/12sort_table) |  
| 环节3: 数据清洗 | ● 识别离群点（Outlier）<br>● 实现噪声过滤预处理<br>● 处理时间戳乱序数据 | 20分钟 | [噪声生成器](https://bit.ly/12noise_gen) |  
| 环节4: 具身实践 | ● 基础组：单维度距离排序<br>● 进阶组：极坐标转换排序<br>● 挑战组：多雷达数据归并 | 30分钟 | [雷达模拟器](https://bit.ly/12lidar_sim) |  
| 环节5: 总结提升 | ● 工业级排序案例解析<br>● 展示TensorFlow数据管道 | 5分钟 | [TF数据API](https://bit.ly/12tf_data) |  

## 课程总结  
| 内容 | 主要内容 | 预计时长 | 素材附件 |  
|------|----------|----------|----------|  
| A 拓展任务 | ● 实现动态阈值自适应排序<br>● 设计断电数据续排机制 | - | - |  
| B 课程总结 | ● 排序算法全景图谱<br>● 数据丢失事故分析 | - | - |  
| C 课后作业 | ● 优化排序内存占用<br>● 预习快速排序算法 | - | - |  

---

### 工业级功能扩展：  
1. ​**雷达模拟器**支持：  
   - 10种噪声模式（高斯/脉冲/周期）  
   - 多雷达同步扫描模拟  
   - 点云数据格式转换（XYZ→极坐标）  
2. ​**排序可视化工具**包含：  
   - 实时交换次数计数器  
   - 算法执行轨迹热力图  
   - 性能对比柱状图  
3. ​**点云数据集**涵盖：  
   - 城市/森林/隧道典型场景  
   - 动态障碍物运动轨迹  
   - 多分辨率采样数据  

```python
# 带噪声过滤的冒泡排序
def bubble_sort_filter(data):
    n = len(data)
    for i in range(n):
        for j in range(0, n-i-1):
            # 噪声过滤：忽略异常大值
            if abs(data[j] - data[j+1]) > 3 * np.std(data):
                continue
            if data[j] > data[j+1]:
                data[j], data[j+1] = data[j+1], data[j]
    return data

# 使用示例
lidar_data = [3.2, 3.1, 10.5, 2.9, 3.0]  # 含噪声数据
print(bubble_sort_filter(lidar_data))  # 输出: [2.9, 3.0, 3.1, 3.2, 10.5]