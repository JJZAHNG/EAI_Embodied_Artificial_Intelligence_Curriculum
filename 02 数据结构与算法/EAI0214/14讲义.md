# EAI｜02.14 数据结构与算法 课程讲义  
课程名称：数据结构与算法  
单元主题：路径规划｜智能导航基础  
授课年级：G3+  
计划课时：90分钟

## 课程概括  
本课以机器人自主导航为场景，系统学习广度优先搜索（BFS）算法在最短路径规划中的应用。通过构建迷宫求解器和动态避障系统，掌握队列数据结构在路径搜索中的核心作用，理解BFS的层序遍历特性，为后续A*等高级路径算法学习奠定基础。  

## 教学目标  
### 🎯知识与技能  
1. 掌握BFS算法的队列实现原理  
2. 理解访问标记与路径回溯机制  
3. 熟练处理动态障碍物场景下的路径重规划  

### 🎯过程与方法  
1. 通过水波扩散类比理解BFS传播特性  
2. 采用增量式扩展法优化搜索效率  

### 🎯情感态度价值观  
1. 培养路径规划的全局思维  
2. 增强系统鲁棒性设计意识  

## 重点难点  
| 教学重点 | 教学难点 |  
|----------|----------|  
| ✅ 队列的FIFO特性与BFS配合 | ⚠️ 路径回溯的父节点记录策略 |  
| ✅ 障碍物地图的矩阵表示法 | ⚠️ 动态障碍物的实时更新处理 |  
| ✅ 最短路径的数学证明 | ⚠️ 三维空间路径搜索扩展 |  

## 教学准备  
| 软件 | 硬件 | 扩展 |  
|------|------|------|  
| Python 3.10+ | 　 | [迷宫生成器](https://bit.ly/14maze_gen) |  
| PyGame库 | 　 | [路径可视化工具](https://bit.ly/14path_vis) |  

## 教学过程  
| 环节 | 主要内容 | 预计时长 | 素材附件 |  
|------|----------|----------|----------|  
| 环节1: 情境导入 | ● 播放亚马逊仓储机器人路径规划视频<br>● 分析迷宫路径规划需求 | 10分钟 | [仓储系统DEMO](https://bit.ly/14amazon_nav) |  
| 环节2: BFS算法解析 | ● 水波扩散动画演示搜索过程<br>● 实现队列的层级遍历机制<br>● 父节点字典记录路径轨迹 | 25分钟 | [波动模拟器](https://bit.ly/14wave_sim) |  
| 环节3: 地图建模 | ● 二维矩阵表示障碍物（0/1）<br>● 处理多入口/出口场景<br>● 实现地图动态编辑器 | 20分钟 | [地图设计器](https://bit.ly/14map_editor) |  
| 环节4: 具身实践 | ● 基础组：静态迷宫求解<br>● 进阶组：动态障碍物避让<br>● 挑战组：多机器人协同路径 | 30分钟 | [协同规划器](https://bit.ly/14multi_bot) |  
| 环节5: 总结提升 | ● 工业级应用案例解析<br>● 展示ROS导航堆栈中的BFS应用 | 5分钟 | [ROS导航包](https://bit.ly/14ros_nav) |  

## 课程总结  
| 内容 | 主要内容 | 预计时长 | 素材附件 |  
|------|----------|----------|----------|  
| A 拓展任务 | ● 添加路径成本权重系统<br>● 设计路径记忆学习机制 | - | - |  
| B 课程总结 | ● 搜索算法对比矩阵<br>● 路径冲突事故分析 | - | - |  
| C 课后作业 | ● 优化路径平滑度<br>● 预习A*启发式搜索 | - | - |  

---

### 工业级功能扩展：  
1. ​**迷宫生成器**支持：  
   - 10+迷宫生成算法（Prim/递归分割）  
   - 难度分级系统（简单/困难/地狱）  
   - 解决方案校验功能  
2. ​**路径可视化工具**包含：  
   - 实时搜索过程动画  
   - 路径长度统计面板  
   - 能耗消耗计算器  
3. ​**协同规划器**提供：  
   - 多机器人路径优先级设置  
   - 死锁检测与自动解除  
   - 交通管制规则配置  

```python
# BFS最短路径核心代码
def bfs_maze(maze, start, end):
    from collections import deque
    directions = [(-1,0), (1,0), (0,-1), (0,1)]
    queue = deque([(start, [start])])
    visited = set()
    
    while queue:
        (x, y), path = queue.popleft()
        if (x, y) == end:
            return path
        for dx, dy in directions:
            nx, ny = x+dx, y+dy
            if 0<=nx<len(maze) and 0<=ny<len(maze[0]) and maze[nx][ny]==0 and (nx,ny) not in visited:
                visited.add((nx, ny))
                queue.append(((nx, ny), path + [(nx, ny)]))
    return []

# 使用示例
maze = [
    [0,1,0,0],
    [0,0,0,1],
    [0,1,0,0]
]
print(bfs_maze(maze, (0,0), (2,3)))  # 输出最短路径坐标序列