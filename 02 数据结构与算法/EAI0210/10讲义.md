# EAI｜02.10 数据结构与算法 课程讲义  
课程名称：数据结构与算法  
单元主题：图结构｜空间拓扑建模  
授课年级：G3+  
计划课时：90分钟  

## 课程概括  
本课以机器人环境建模为核心场景，系统学习图结构的节点-边关系表示方法。通过构建室内空间拓扑图和实现连通域分析算法，掌握邻接表与邻接矩阵的实现策略，理解图遍历在路径规划中的基础作用，为后续SLAM（同步定位与建图）系统开发奠定图论基础。  

## 教学目标  
### 🎯知识与技能  
1. 掌握图结构的基本术语（节点/边/度/连通分量）  
2. 理解邻接表与邻接矩阵的存储差异  
3. 熟练实现基于DFS的连通域分析算法  

### 🎯过程与方法  
1. 通过地铁线路图类比理解图结构  
2. 采用增量式构建法完善拓扑关系  

### 🎯情感态度价值观  
1. 培养空间建模的系统思维  
2. 增强复杂系统抽象能力  

## 重点难点  
| 教学重点 | 教学难点 |  
|----------|----------|  
| ✅ 邻接表的字典嵌套实现 | ⚠️ 稀疏图的存储优化策略 |  
| ✅ 连通域标记的DFS/BFS实现 | ⚠️ 动态图的增量式更新 |  
| ✅ 拓扑图的可视化呈现 | ⚠️ 大规模图的并行计算 |  

## 教学准备  
| 软件 | 硬件 | 扩展 |  
|------|------|------|  
| Python 3.10+ | 　 | [图可视化工具](https://bit.ly/10graph_vis) |  
| NetworkX库 | 　 | [建筑平面图数据集](https://bit.ly/10floorplan) |  

## 教学过程  
| 环节 | 主要内容 | 预计时长 | 素材附件 |  
|------|----------|----------|----------|  
| 环节1: 情境导入 | ● 展示波士顿动力Atlas的导航地图<br>● 分析商场机器人导购路径规划需求 | 10分钟 | [Atlas导航视频](https://bit.ly/10atlas_nav) |  
| 环节2: 图结构解析 | ● 用地铁线路图类比节点与边<br>● 对比邻接表与矩阵的内存消耗<br>● 绘制教室座位关系拓扑图 | 20分钟 | [地铁线路图](https://bit.ly/10subway_map) |  
| 环节3: 邻接表实战 | ● 字典嵌套实现节点连接关系<br>● 动态添加障碍物节点<br>● 实现度数中心性计算 | 25分钟 | [邻接表调试器](https://bit.ly/10adj_debug) |  
| 环节4: 具身实践 | ● 基础组：标记简单房间连通域<br>● 进阶组：处理含障碍物的复杂平面<br>● 挑战组：实时更新动态拓扑图 | 30分钟 | [平面图编辑器](https://bit.ly/10plan_edit) |  
| 环节5: 总结提升 | ● 工业级图数据库案例解析<br>● 展示Neo4j在物流机器人中的应用 | 5分钟 | [Neo4j白皮书](https://bit.ly/10neo4j_doc) |  

## 课程总结  
| 内容 | 主要内容 | 预计时长 | 素材附件 |  
|------|----------|----------|----------|  
| A 拓展任务 | ● 添加多楼层垂直连通分析<br>● 设计热力图生成系统 | - | - |  
| B 课程总结 | ● 图结构类型全景图<br>● 环路检测问题分析 | - | - |  
| C 课后作业 | ● 优化连通域标记算法<br>● 预习最短路径算法 | - | - |  

---

### 工业级功能扩展：  
1. ​**平面图编辑器**支持以下高级功能：  
   - 10种标准障碍物模板（门/窗/立柱）  
   - 实时连通性校验（红绿灯提示）  
   - 导出GIS标准格式文件  
2. ​**邻接表调试器**包含：  
   - 内存占用量化分析  
   - 遍历路径动画演示  
   - 虚拟断点调试功能  
3. ​**建筑平面图数据集**涵盖：  
   - 50+真实建筑平面图（商场/办公楼/医院）  
   - 多楼层关联拓扑数据  
   - 人流量热点标记  

```python
# 连通域标记算法示例
def count_rooms(graph):
    visited = set()
    count = 0
    for node in graph:
        if node not in visited:
            dfs(node, graph, visited)
            count += 1
    return count

def dfs(node, graph, visited):
    if node in visited:
        return
    visited.add(node)
    for neighbor in graph[node]:
        dfs(neighbor, graph, visited)

# 使用示例
floor_plan = {
    'A': ['B', 'C'],
    'B': ['A'],
    'C': ['A', 'D'],
    'D': ['C'],
    'E': ['F'],
    'F': ['E']
}
print(count_rooms(floor_plan))  # 输出：2个连通域